"use strict";(self.webpackChunkpointnetwork_github_io=self.webpackChunkpointnetwork_github_io||[]).push([[8225],{3905:(e,a,t)=>{t.d(a,{Zo:()=>d,kt:()=>g});var n=t(7294);function r(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);a&&(n=n.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,n)}return t}function i(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){r(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function l(e,a){if(null==e)return{};var t,n,r=function(e,a){if(null==e)return{};var t,n,r={},o=Object.keys(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||(r[t]=e[t]);return r}(e,a);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)t=o[n],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var s=n.createContext({}),p=function(e){var a=n.useContext(s),t=a;return e&&(t="function"==typeof e?e(a):i(i({},a),e)),t},d=function(e){var a=p(e.components);return n.createElement(s.Provider,{value:a},e.children)},u={inlineCode:"code",wrapper:function(e){var a=e.children;return n.createElement(n.Fragment,{},a)}},c=n.forwardRef((function(e,a){var t=e.components,r=e.mdxType,o=e.originalType,s=e.parentName,d=l(e,["components","mdxType","originalType","parentName"]),c=p(t),g=r,h=c["".concat(s,".").concat(g)]||c[g]||u[g]||o;return t?n.createElement(h,i(i({ref:a},d),{},{components:t})):n.createElement(h,i({ref:a},d))}));function g(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var o=t.length,i=new Array(o);i[0]=c;var l={};for(var s in a)hasOwnProperty.call(a,s)&&(l[s]=a[s]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var p=2;p<o;p++)i[p]=t[p];return n.createElement.apply(null,i)}return n.createElement.apply(null,t)}c.displayName="MDXCreateElement"},6145:(e,a,t)=>{t.r(a),t.d(a,{assets:()=>s,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>l,toc:()=>p});var n=t(7462),r=(t(7294),t(3905));const o={title:"Overview",sidebar_label:"Overview"},i="Overview",l={unversionedId:"point_chain/validators/upgrades/overview",id:"point_chain/validators/upgrades/overview",title:"Overview",description:"Learn how to manage chain upgrades for your full and validator nodes.",source:"@site/docs/point_chain/validators/upgrades/overview.md",sourceDirName:"point_chain/validators/upgrades",slug:"/point_chain/validators/upgrades/overview",permalink:"/docs/point_chain/validators/upgrades/overview",draft:!1,editUrl:"https://github.com/pointnetwork/pointnetwork.github.io/edit/main/website/docs/point_chain/validators/upgrades/overview.md",tags:[],version:"current",lastUpdatedBy:"Darren Jensen",lastUpdatedAt:1667471981,formattedLastUpdatedAt:"Nov 3, 2022",frontMatter:{title:"Overview",sidebar_label:"Overview"},sidebar:"pnSidebar",previous:{title:"Backup",permalink:"/docs/point_chain/validators/security/backup"},next:{title:"Upgrades",permalink:"/docs/point_chain/validators/upgrades/"}},s={},p=[{value:"Upgrade Categories",id:"upgrade-categories",level:2},{value:"Planned and Forks Upgrades",id:"planned-and-forks-upgrades",level:2},{value:"Planned Upgrades",id:"planned-upgrades",level:3},{value:"Governance Proposal",id:"governance-proposal",level:4},{value:"Hard Forks",id:"hard-forks",level:4},{value:"Unplanned Upgrades",id:"unplanned-upgrades",level:3},{value:"Breaking and Non-Breaking Upgrades",id:"breaking-and-non-breaking-upgrades",level:3},{value:"Major Versions",id:"major-versions",level:4},{value:"Minor Versions",id:"minor-versions",level:4},{value:"Patch Versions",id:"patch-versions",level:4},{value:"Data Reset Upgrades",id:"data-reset-upgrades",level:3},{value:"Automatic or Manual Upgrades",id:"automatic-or-manual-upgrades",level:3}],d={toc:p};function u(e){let{components:a,...t}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,t,{components:a,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"overview"},"Overview"),(0,r.kt)("p",null,"Learn how to manage chain upgrades for your full and validator nodes."),(0,r.kt)("h2",{id:"upgrade-categories"},"Upgrade Categories"),(0,r.kt)("p",null,"There are 3 different categories for upgrades:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Planned or Unplanned Upgrades"),": Chain upgrades can be scheduled at a given height through an upgrade proposal plan."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Breaking or Non-breaking Upgrades"),": Upgrades can be API or State Machine breaking, which affects backwards compatibility. To address this, the application state or genesis file would need to be migrated in preparation for the upgrade."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Data Reset Upgrades"),": Some upgrades will need a full data reset in order to clean the state. This can sometimes occur in the case of a rollback or hard fork.")),(0,r.kt)("p",null,"Additionally, validators can choose how to manage the upgrade according to their preferred option:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Automatic or Manual Upgrades"),": Validator can run the ",(0,r.kt)("inlineCode",{parentName:"li"},"cosmovisor")," process to automatically perform the upgrade or do it manually.")),(0,r.kt)("h2",{id:"planned-and-forks-upgrades"},"Planned and Forks Upgrades"),(0,r.kt)("h3",{id:"planned-upgrades"},"Planned Upgrades"),(0,r.kt)("p",null,"Planned upgrades are coordinated scheduled upgrades that use the upgrade module logic. This facilitates smoothly upgrading Point Chain to a new (breaking) software version as it automatically handles the state migration for the new release."),(0,r.kt)("h4",{id:"governance-proposal"},"Governance Proposal"),(0,r.kt)("p",null,"Governance Proposals are a mechanism for coordinating an upgrade at a given height or time using an Software Proposal."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"All governance proposals, including software upgrades, need to wait for the voting period to conclude before the upgrade can be executed. Consider this duration when submitting a software upgrade proposal.")),(0,r.kt)("p",null,"If the proposal passes, the upgrade ",(0,r.kt)("inlineCode",{parentName:"p"},"Plan"),", which targets a specific upgrade logic to migrate the state, is persisted to the blockchain state and scheduled at the given upgrade height. The upgrade can be delayed or expedited by updating the ",(0,r.kt)("inlineCode",{parentName:"p"},"Plan.Height")," in a new proposal."),(0,r.kt)("h4",{id:"hard-forks"},"Hard Forks"),(0,r.kt)("p",null,"A special type of planned upgrades are hard forks. Hard Forks, as opposed to [Governance Proposal}(#governance-proposal), don't require waiting for the full voting\nperiod. This makes them ideal for coordinating security vulnerabilities and patches."),(0,r.kt)("p",null,"The upgrade (fork) block height is set in the ",(0,r.kt)("inlineCode",{parentName:"p"},"BeginBlock")," of the application (i.e before the transactions are processed for the block). Once the blockchain reaches that height, it automatically schedules an upgrade ",(0,r.kt)("inlineCode",{parentName:"p"},"Plan")," for the same height and then triggers the upgrade process. After upgrading, the block operations (",(0,r.kt)("inlineCode",{parentName:"p"},"BeginBlock"),", transaction processing and state ",(0,r.kt)("inlineCode",{parentName:"p"},"Commit"),") continue normally."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"In order to execute an upgrade hard fork, a ",(0,r.kt)("a",{parentName:"p",href:"#patch-versions"},"patch version")," needs to first be released with the ",(0,r.kt)("inlineCode",{parentName:"p"},"BeginBlock")," upgrade scheduling logic. After a +2/3 of the validators upgrade to the new patch version, their nodes will automatically halt and upgrade the binary.")),(0,r.kt)("h3",{id:"unplanned-upgrades"},"Unplanned Upgrades"),(0,r.kt)("p",null,"Unplanned upgrades are upgrades where all the validators need to gracefully halt and shut down their nodes at exactly the same point in the process. This can be done by setting the ",(0,r.kt)("inlineCode",{parentName:"p"},"--halt-height")," flag when running the ",(0,r.kt)("inlineCode",{parentName:"p"},"pointd start")," command."),(0,r.kt)("p",null,"If there are breaking changes during an unplanned upgrade (see below), validators will need to migrate the state and genesis before restarting their nodes."),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"The main consideration with unplanned upgrades is that the genesis state needs to be exported and the blockchain data needs to be ",(0,r.kt)("a",{parentName:"p",href:"#data-reset-upgrades"},"reset"),". This mainly affects infrastructure providers, tools and clients like block explorers and clients, which have to use archival nodes to serve queries for the pre-upgrade heights.")),(0,r.kt)("h3",{id:"breaking-and-non-breaking-upgrades"},"Breaking and Non-Breaking Upgrades"),(0,r.kt)("p",null,"Upgrades can be categorized as breaking or non-breaking according to the Semantic versioning (",(0,r.kt)("a",{parentName:"p",href:"https://semver.org/"},"Semver"),") of the corresponding software ",(0,r.kt)("a",{parentName:"p",href:"https://github.com/pointnetwork/point-chain/releases"},"release version")," (",(0,r.kt)("em",{parentName:"p"},"i.e")," ",(0,r.kt)("inlineCode",{parentName:"p"},"vX.Y.Z"),"):"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Major version (",(0,r.kt)("inlineCode",{parentName:"strong"},"X"),")"),": backward incompatible API and state machine breaking changes."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Minor version (",(0,r.kt)("inlineCode",{parentName:"strong"},"Y"),")"),": new backward compatible features. These can be also be state machine breaking."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"Patch version (",(0,r.kt)("inlineCode",{parentName:"strong"},"Z"),")"),": backwards compatible bug fixes, small refactors and improvements.")),(0,r.kt)("h4",{id:"major-versions"},"Major Versions"),(0,r.kt)("p",null,"If the new version you are upgrading to has breaking changes, you will have to:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Migrate genesis JSON"),(0,r.kt)("li",{parentName:"ol"},"Migrate application state"),(0,r.kt)("li",{parentName:"ol"},"Restart node")),(0,r.kt)("p",null,"This needs to be done to prevent ",(0,r.kt)("a",{parentName:"p",href:"https://docs.tendermint.com/master/spec/consensus/signing.html#double-signing"},"double signing or halting the chain during consensus"),"."),(0,r.kt)("p",null,"To upgrade the genesis file, you can either fetch it from a trusted source or export it locally using the ",(0,r.kt)("inlineCode",{parentName:"p"},"pointd export")," command."),(0,r.kt)("h4",{id:"minor-versions"},"Minor Versions"),(0,r.kt)("p",null,"If the new version you are upgrading to has breaking changes, you will have to:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Migrate the state (if applicable)"),(0,r.kt)("li",{parentName:"ol"},"Restart node")),(0,r.kt)("h4",{id:"patch-versions"},"Patch Versions"),(0,r.kt)("p",null,"In order to update a patch:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Stop Node"),(0,r.kt)("li",{parentName:"ol"},"Download new release binary manually"),(0,r.kt)("li",{parentName:"ol"},"Restart node")),(0,r.kt)("h3",{id:"data-reset-upgrades"},"Data Reset Upgrades"),(0,r.kt)("p",null,"Data Reset upgrades require node operators to fully reset the blockchain state and restart their nodes from a clean\nstate, but using the same validator keys."),(0,r.kt)("h3",{id:"automatic-or-manual-upgrades"},"Automatic or Manual Upgrades"),(0,r.kt)("p",null,"With every new software release, we strongly recommend full nodes and validator operators to perform a software upgrade."),(0,r.kt)("p",null,"You can upgrade your node by either:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"/docs/point_chain/validators/upgrades/automated"},"automatically")," bumping the software version and restart the node once the upgrade occurs, or"),(0,r.kt)("li",{parentName:"ul"},"download the new binary and perform a ",(0,r.kt)("a",{parentName:"li",href:"/docs/point_chain/validators/upgrades/manual"},"manual upgrade"))),(0,r.kt)("p",null,"Follow the links in the options above to learn how to upgrade your node according to your preferred option."))}u.isMDXComponent=!0}}]);