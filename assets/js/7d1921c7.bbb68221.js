"use strict";(self.webpackChunk=self.webpackChunk||[]).push([[8004],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return m}});var r=t(67294);function o(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function a(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){o(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,o=function(e,n){if(null==e)return{};var t,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(o[t]=e[t]);return o}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(o[t]=e[t])}return o}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):a(a({},n),e)),t},d=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,o=e.mdxType,i=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=l(t),m=o,f=p["".concat(c,".").concat(m)]||p[m]||u[m]||i;return t?r.createElement(f,a(a({ref:n},d),{},{components:t})):r.createElement(f,a({ref:n},d))}));function m(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var i=t.length,a=new Array(i);a[0]=p;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var l=2;l<i;l++)a[l]=t[l];return r.createElement.apply(null,a)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},14645:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return c},metadata:function(){return l},toc:function(){return d},default:function(){return p}});var r=t(83117),o=t(80102),i=(t(67294),t(3905)),a=["components"],s={title:"Encoding",sidebar_label:"Encoding"},c="Encoding",l={unversionedId:"point_chain/users/technical_concepts/encoding",id:"point_chain/users/technical_concepts/encoding",title:"Encoding",description:"Learn about the encoding formats used on Point Chain.",source:"@site/docs/point_chain/users/technical_concepts/encoding.md",sourceDirName:"point_chain/users/technical_concepts",slug:"/point_chain/users/technical_concepts/encoding",permalink:"/docs/point_chain/users/technical_concepts/encoding",editUrl:"https://github.com/pointnetwork/pointnetwork.github.io/edit/main/website/docs/point_chain/users/technical_concepts/encoding.md",tags:[],version:"current",lastUpdatedBy:"Darren Jensen",lastUpdatedAt:1663321891,formattedLastUpdatedAt:"9/16/2022",frontMatter:{title:"Encoding",sidebar_label:"Encoding"},sidebar:"pnSidebar",previous:{title:"Chain ID",permalink:"/docs/point_chain/users/technical_concepts/chain_id"},next:{title:"Pending State",permalink:"/docs/point_chain/users/technical_concepts/pending_state"}},d=[{value:"Pre-requisite Readings",id:"pre-requisite-readings",children:[],level:2},{value:"Encoding Formats",id:"encoding-formats",children:[{value:"Protocol Buffers",id:"protocol-buffers",children:[],level:3},{value:"Amino",id:"amino",children:[],level:3},{value:"RLP",id:"rlp",children:[],level:3}],level:2}],u={toc:d};function p(e){var n=e.components,t=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"encoding"},"Encoding"),(0,i.kt)("p",null,"Learn about the encoding formats used on Point Chain."),(0,i.kt)("h2",{id:"pre-requisite-readings"},"Pre-requisite Readings"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://docs.cosmos.network/main/core/encoding.html"},"Cosmos SDK Encoding")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://eth.wiki/en/fundamentals/rlp"},"Ethereum RLP"))),(0,i.kt)("h2",{id:"encoding-formats"},"Encoding Formats"),(0,i.kt)("h3",{id:"protocol-buffers"},"Protocol Buffers"),(0,i.kt)("p",null,"The Cosmos ",(0,i.kt)("a",{parentName:"p",href:"https://stargate.cosmos.network/"},"Stargate")," release introduces\n",(0,i.kt)("a",{parentName:"p",href:"https://developers.google.com/protocol-buffers"},"protobuf")," as the main encoding format for both\nclient and state serialization. All the EVM module types that are used for state and clients\n(transaction messages, genesis, query services, etc) will be implemented as protocol buffer messages."),(0,i.kt)("h3",{id:"amino"},"Amino"),(0,i.kt)("p",null,"The Cosmos SDK also supports the legacy Amino encoding format for backwards compatibility with\nprevious versions, specially for client encoding and signing with Ledger devices. Point Chain does not\nsupport Amino in the EVM module, but it is supported for all other Cosmos SDK modules that enable it."),(0,i.kt)("h3",{id:"rlp"},"RLP"),(0,i.kt)("p",null,"Recursive Length Prefix (",(0,i.kt)("a",{parentName:"p",href:"https://eth.wiki/en/fundamentals/rlp"},"RLP"),"), is an encoding/decoding algorithm that serializes a message and\nallows for quick reconstruction of encoded data. Point Chain uses RLP to encode/decode Ethereum\nmessages for JSON-RPC handling to conform messages to the proper Ethereum format. This allows\nmessages to be encoded and decoded in the exact format as Ethereum's."),(0,i.kt)("p",null,"The ",(0,i.kt)("inlineCode",{parentName:"p"},"x/evm")," transactions (",(0,i.kt)("inlineCode",{parentName:"p"},"MsgEthereumTx"),") encoding is performed by casting the message to a go-ethereum's ",(0,i.kt)("inlineCode",{parentName:"p"},"Transaction")," and then marshaling the transaction data using RLP:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-go"},"// TxEncoder overwrites sdk.TxEncoder to support MsgEthereumTx\nfunc (g txConfig) TxEncoder() sdk.TxEncoder {\n  return func(tx sdk.Tx) ([]byte, error) {\n    msg, ok := tx.(*evmtypes.MsgEthereumTx)\n    if ok {\n      return msg.AsTransaction().MarshalBinary()\n   }\n    return g.TxConfig.TxEncoder()(tx)\n  }\n}\n\n// TxDecoder overwrites sdk.TxDecoder to support MsgEthereumTx\nfunc (g txConfig) TxDecoder() sdk.TxDecoder {\n  return func(txBytes []byte) (sdk.Tx, error) {\n    tx := &ethtypes.Transaction{}\n\n    err := tx.UnmarshalBinary(txBytes)\n    if err == nil {\n      msg := &evmtypes.MsgEthereumTx{}\n      msg.FromEthereumTx(tx)\n      return msg, nil\n    }\n\n    return g.TxConfig.TxDecoder()(txBytes)\n  }\n}\n")))}p.isMDXComponent=!0}}]);