"use strict";(self.webpackChunkpointnetwork_github_io=self.webpackChunkpointnetwork_github_io||[]).push([[3099],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var i=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},r=Object.keys(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(i=0;i<r.length;i++)n=r[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=i.createContext({}),l=function(e){var t=i.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return i.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},h=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),h=l(n),u=a,m=h["".concat(c,".").concat(u)]||h[u]||d[u]||r;return n?i.createElement(m,o(o({ref:t},p),{},{components:n})):i.createElement(m,o({ref:t},p))}));function u(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=h;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var l=2;l<r;l++)o[l]=n[l];return i.createElement.apply(null,o)}return i.createElement.apply(null,n)}h.displayName="MDXCreateElement"},1421:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var i=n(7462),a=(n(7294),n(3905));const r={title:"Pending State",sidebar_label:"Pending State"},o="Pending State",s={unversionedId:"point_chain/users/technical_concepts/pending_state",id:"point_chain/users/technical_concepts/pending_state",title:"Pending State",description:"Learn how Point Chain handles pending state queries.",source:"@site/docs/point_chain/users/technical_concepts/pending_state.md",sourceDirName:"point_chain/users/technical_concepts",slug:"/point_chain/users/technical_concepts/pending_state",permalink:"/docs/point_chain/users/technical_concepts/pending_state",draft:!1,editUrl:"https://github.com/pointnetwork/pointnetwork.github.io/edit/main/website/docs/point_chain/users/technical_concepts/pending_state.md",tags:[],version:"current",lastUpdatedBy:"Darren Jensen",lastUpdatedAt:1665224535,formattedLastUpdatedAt:"Oct 8, 2022",frontMatter:{title:"Pending State",sidebar_label:"Pending State"},sidebar:"pnSidebar",previous:{title:"Encoding",permalink:"/docs/point_chain/users/technical_concepts/encoding"},next:{title:"Validator's Overview",permalink:"/docs/point_chain/validators/overview"}},c={},l=[{value:"Pre-requisite Readings",id:"pre-requisite-readings",level:2},{value:"Point Chain vs Ethereum",id:"point-chain-vs-ethereum",level:2},{value:"Pending State Queries",id:"pending-state-queries",level:2},{value:"JSON-RPC Calls on Pending Transactions",id:"json-rpc-calls-on-pending-transactions",level:3}],p={toc:l};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,i.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"pending-state"},"Pending State"),(0,a.kt)("p",null,"Learn how Point Chain handles pending state queries."),(0,a.kt)("h2",{id:"pre-requisite-readings"},"Pre-requisite Readings"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"https://docs.tendermint.com/master/tendermint-core/mempool/"},"Tendermint Mempool"))),(0,a.kt)("h2",{id:"point-chain-vs-ethereum"},"Point Chain vs Ethereum"),(0,a.kt)("p",null,"In Ethereum, pending blocks are generated as they are queued for production by miners. These pending\nblocks include pending transactions that are picked out by miners, based on the highest reward paid\nin gas. This mechanism exists as block finality is not possible on the Ethereum network. Blocks are\ncommitted with probabilistic finality, which means that transactions and blocks become less likely\nto become reverted as more time (and blocks) passes."),(0,a.kt)("p",null,'Point Chain is designed quite differently on this front as there is no concept of a "pending state".\nPoint Chain uses ',(0,a.kt)("a",{parentName:"p",href:"https://docs.tendermint.com/"},"Tendermint Core")," BFT consensus which provides instant\nfinality for transaction. For this reason, Ethermint does not require a pending state mechanism, as\nall (if not most) of the transactions will be committed to the next block (avg. block time on Cosmos chains is ~8s). However, this causes a\nfew hiccups in terms of the Ethereum Web3-compatible queries that can be made to pending state."),(0,a.kt)("p",null,"Another significant difference with Ethereum, is that blocks are produced by validators or block producers, who include transactions from their local mempool into blocks in a\nfirst-in-first-out (FIFO) fashion. Transactions on Point Chain cannot be ordered or cherry picked out from the Tendermint node ",(0,a.kt)("a",{parentName:"p",href:"https://docs.tendermint.com/master/tendermint-core/mempool/"},"mempool"),"."),(0,a.kt)("h2",{id:"pending-state-queries"},"Pending State Queries"),(0,a.kt)("p",null,"Point Chain will make queries which will account for any unconfirmed transactions present in a node's\ntransaction mempool. A pending state query made will be subjective and the query will be made on the\ntarget node's mempool. Thus, the pending state will not be the same for the same query to two\ndifferent nodes."),(0,a.kt)("h3",{id:"json-rpc-calls-on-pending-transactions"},"JSON-RPC Calls on Pending Transactions"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/point_chain/developers/json-rpc/endpoints#eth_getbalance"},(0,a.kt)("inlineCode",{parentName:"a"},"eth_getBalance"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/point_chain/developers/json-rpc/endpoints#eth-gettransactioncount"},(0,a.kt)("inlineCode",{parentName:"a"},"eth_getTransactionCount"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/point_chain/developers/json-rpc/endpoints#eth-getblocktransactioncountbynumber"},(0,a.kt)("inlineCode",{parentName:"a"},"eth_getBlockTransactionCountByNumber"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/point_chain/developers/json-rpc/endpoints#eth-getblockbynumber"},(0,a.kt)("inlineCode",{parentName:"a"},"eth_getBlockByNumber"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/point_chain/developers/json-rpc/endpoints#eth-gettransactionbyhash"},(0,a.kt)("inlineCode",{parentName:"a"},"eth_getTransactionByHash"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/point_chain/developers/json-rpc/endpoints#eth-gettransactionbyblockhashandindex"},(0,a.kt)("inlineCode",{parentName:"a"},"eth_getTransactionByBlockNumberAndIndex"))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("a",{parentName:"li",href:"/docs/point_chain/developers/json-rpc/endpoints#eth-sendtransaction"},(0,a.kt)("inlineCode",{parentName:"a"},"eth_sendTransaction")))))}d.isMDXComponent=!0}}]);